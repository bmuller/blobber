/******************************************************************************
* FOBS Java CrossPlatform JMF PlugIn
* Copyright (c) 2004 Omnividea Multimedia S.L
*
*    This file is part of FOBS.
*
*    FOBS is free software; you can redistribute it and/or modify
*    it under the terms of the GNU Lesser General Public License as
*    published by the Free Software Foundation; either version 2.1 
*    of the License, or (at your option) any later version.
*
*    FOBS is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU Lesser General Public License for more details.
*
*    You should have received a copy of the GNU Lesser General Public
*    License along with FOBS; if not, write to the Free Software
*    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
******************************************************************************/

/*
 * Created on 06.02.2005 by Robert Binna
 * ChangeLog:
 *  Jose San Pedro Wandelmer 2005/02/21 - Major changes to code structure
 *      - Package changed to fit Fobs package naming
 *      - Automatic Generated comments removed
 *      - Header included with license information
 *      - Jogl animator use have been removed. Explicit calls to display() seems to be more efficient.
 *      - The Renderer is generated by the class (FlatRenderer only at the moment)
 *      - Thanks to Robert Binna for his contribution to the project!!
 *  Robert Hastings 2007/01/04
 *      - Native Library Location routines
 *      - Improvements to frame buffer management
 */

package com.omnividea.media.renderer.video;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Image;
import java.awt.Rectangle;
import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferInt;

import javax.media.Buffer;
import javax.media.Format;
import javax.media.ResourceUnavailableException;
import javax.media.format.RGBFormat;
import javax.media.renderer.VideoRenderer;
import javax.media.control.FrameGrabbingControl; 
import javax.media.util.ImageToBuffer;

import net.java.games.jogl.Animator;
import net.java.games.jogl.GLCanvas;
import net.java.games.jogl.GLCapabilities;
import net.java.games.jogl.GLDrawableFactory;
import javax.swing.JPanel;

import com.omnividea.media.renderer.video.opengl.RenderEventListener;
import com.omnividea.media.renderer.video.opengl.FlatRenderer;
import com.omnividea.FobsConfiguration;

public class OpenGLRenderer implements VideoRenderer, FrameGrabbingControl {

    private BufferStrategy strategy;
    private GLCanvas canvas;
    private Animator animator = null;
    private RenderEventListener listener;
    private FlatRenderer flatRenderer = null;
    private JPanel panel = null;
    private Image lastImage;

    public OpenGLRenderer() {
        GLCapabilities capbilities = new GLCapabilities();
        capbilities.setDoubleBuffered(true);
        capbilities.setAlphaBits(8);
        capbilities.setRedBits(8);
        capbilities.setGreenBits(8);
        capbilities.setBlueBits(8);        
        System.out.println("OpenGL Renderer: cons");
        canvas = GLDrawableFactory.getFactory().createGLCanvas(capbilities);
        flatRenderer = new FlatRenderer();
        //flatRenderer.init(canvas);
        addRenderEventListener(flatRenderer);
        panel = new JPanel();
        panel.setIgnoreRepaint(true);
        panel.add(canvas);
    }
    
    public void addRenderEventListener(RenderEventListener listener) {
        System.out.println("OpenGL Renderer: add Render Event");
        this.listener = listener;
        canvas.addGLEventListener(listener);
        canvas.addMouseMotionListener(listener);
    }
    
	private RGBFormat vf;
    private BufferedImage bufferedImage;
    private int []pixels;
    //private int[][] pixels = new int[2][];
    
    private int formatWidth;
    private int formatHeight;
    private int currentIndex = 0;
    
    void setValue(Object aValue,boolean isSelected) {
        System.out.println(aValue.getClass().getName());
    }

    public Format[] getSupportedInputFormats() {
        RGBFormat format = new RGBFormat();
        return new Format[] {  format };
    }

    public Format setInputFormat(Format format) {
        FobsConfiguration.reset();
        FobsConfiguration.videoFrameFormat=FobsConfiguration.YUV420;

/*        vf = (RGBFormat) format;
		this.formatWidth = (int) vf.getSize().getWidth();
	    this.formatHeight = (int) vf.getSize().getHeight();
	    listener.setFormat(formatWidth,formatHeight);
	    pixels[0] = new int[formatWidth * formatHeight];
	    pixels[1] = new int[formatWidth * formatHeight];

        FobsConfiguration.videoFrameFormat=FobsConfiguration.RGBA;*/

        vf = (RGBFormat) format;
		int formatWidth = (int) vf.getSize().getWidth();
	    int formatHeight = (int) vf.getSize().getHeight();
	    listener.setFormat(formatWidth,formatHeight);
        
        /*
        bufferedImage = new BufferedImage(formatWidth,formatHeight, BufferedImage.TYPE_INT_RGB);
        pixels = ( (DataBufferInt) bufferedImage.getRaster().getDataBuffer()).getData();
        
        FobsConfiguration.properties.put("BufferedImage", bufferedImage);
        FobsConfiguration.properties.put("BufferedImageIntBuffer", pixels);
	    */
        
	    canvas.setSize(new Dimension(formatWidth,formatHeight));
	    panel.setPreferredSize(new Dimension(formatWidth,formatHeight));
        return format;
    }

    public void start() {
        /*
        if(animator == null) {
            animator = new Animator(canvas);
            animator.start();
            System.out.println("animator started");
        }*/
        
    }

    public void stop() {
        /*
        if(animator != null) {
            animator.stop();
            animator = null;
        }
        */
    }

    public int process(Buffer buffer) {
        
        /*int[] bufferdata = (int[]) buffer.getData();
        int nextIndex = (currentIndex +1)%2;
        currentIndex = nextIndex;
        */
        /*
        int[] destination = pixels[nextIndex];
        int size = destination.length;
        int offsetSrc = 0;
        int offsetDest = destination.length - formatWidth;
		for(int i=0; i < formatHeight; ++i) { 
		    for(int j=formatWidth - 1; j >= 0; --j) {
		        destination[offsetDest] = (bufferdata[offsetSrc] << 8);
		        ++offsetDest;
		        ++offsetSrc;
		    }
		    
		    offsetDest -= formatWidth * 2;
		}
		
		if(listener != null) {
		    listener.setRenderingData(pixels[currentIndex]);
            canvas.display();
		}
        */
		if(listener != null) {
		    listener.setRenderingData(pixels/*bufferdata*/);
            canvas.display();
		}

		
		
		return BUFFER_PROCESSED_OK;
    }

    public String getName() {
        return "Fobs GL Renderer";
    }

    public void open() throws ResourceUnavailableException {
    }

    public void close() {
        
        
    }

    public void reset() {
    }


    public Component getComponent() {
        //return canvas;
        return panel;
    }

    public boolean setComponent(Component arg0) {
        return false;
    }

    public void setBounds(Rectangle arg0) {
        System.out.println("set bounds :: " + arg0);
        
    }

    public Rectangle getBounds() {
        return null;
    }
    
    
    
  // support for FrameGrabbingControl 
  public Buffer grabFrame() { 
    //BufferedImage bufimg = (BufferedImage)FobsConfiguration.properties.get("BufferedImage"); 
    Buffer buf = ImageToBuffer.createBuffer(lastImage,(float)0); 
    return buf; 
  } 
   
  // No awt component is needed for FrameGrabbingControl 
  public Component getControlComponent() { 
    return null; 
  } 
   
  public Object[] getControls() { 
    Object[] obj = { this }; 
    return obj; 
  } 
   
  public Object getControl(String arg) { 
    Object rc = null; 
    if(arg.equals("javax.media.control.FrameGrabbingControl")) rc = this; 
    return rc; 
  } 
  // new code-end 
}
